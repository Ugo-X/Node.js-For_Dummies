import { isFilter, has } from './filters.js';
import { QueryIterator } from './QueryIterator.js';
import { EventSubscriber } from '@a-type/utils';
export class Query extends EventSubscriber {
    get generation() {
        return this._generation;
    }
    constructor(game) {
        super();
        this.game = game;
        this.filter = [];
        this.archetypes = new Array();
        this.trackedEntities = [];
        this.addedThisFrame = [];
        this.removedThisFrame = [];
        this.changesThisFrame = 0;
        this.unsubscribes = [];
        this.unsubscribeArchetypes = undefined;
        this._generation = 0;
        this.processDef = (userDef) => {
            return userDef.map((fil) => (isFilter(fil) ? fil : has(fil)));
        };
        this.matchArchetype = (archetype) => {
            let match = true;
            for (const filter of this.filter) {
                switch (filter.kind) {
                    case 'has':
                        match = archetype.includes(filter.Component);
                        break;
                    case 'not':
                        match = archetype.omits(filter.Component);
                        break;
                    case 'changed':
                        match = archetype.includes(filter.Component);
                        break;
                    case 'oneOf':
                        match = filter.Components.some((Comp) => archetype.includes(Comp));
                }
                if (!match)
                    return;
            }
            this.archetypes.push(archetype);
            this.game.logger.debug(`Query ${this.toString()} added Archetype ${archetype.id}`);
            this.unsubscribes.push(archetype.subscribe('entityRemoved', this.handleEntityRemoved));
            this.unsubscribes.push(archetype.subscribe('entityAdded', this.handleEntityAdded));
        };
        this.reset = () => {
            var _a;
            this.archetypes.length = 0;
            this.filter = [];
            (_a = this.unsubscribeArchetypes) === null || _a === void 0 ? void 0 : _a.call(this);
        };
        // closure provides iterator properties
        this.iterator = new QueryIterator(this, this.game);
        this.first = () => {
            return this.iterator.first();
        };
        this.handleEntityAdded = (entity) => {
            this.addToList(entity.id);
            this._generation++;
        };
        this.handleEntityRemoved = (entityId) => {
            this.removeFromList(entityId);
            this._generation++;
        };
        this.addToList = (entityId) => {
            this.trackedEntities.push(entityId);
            const removedIndex = this.removedThisFrame.indexOf(entityId);
            if (removedIndex !== -1) {
                // this was a transfer (removes happen first)
                this.removedThisFrame.splice(removedIndex, 1);
                this.changesThisFrame--;
            }
            else {
                // only non-transfers count as adds
                this.addedThisFrame.push(entityId);
                this.changesThisFrame++;
            }
        };
        this.removeFromList = (entityId) => {
            const index = this.trackedEntities.indexOf(entityId);
            if (index === -1)
                return;
            this.trackedEntities.splice(index, 1);
            this.removedThisFrame.push(entityId);
            this.changesThisFrame++;
        };
        this.resetStepTracking = () => {
            this.addedThisFrame.length = 0;
            this.removedThisFrame.length = 0;
            this.changesThisFrame = 0;
        };
        this.processAddRemove = () => {
            if (this.changesThisFrame) {
                this.addedThisFrame.forEach(this.emitAdded);
                this.removedThisFrame.forEach(this.emitRemoved);
            }
        };
        this.emitAdded = (entityId) => {
            this.game.logger.debug(`Entity ${entityId} added to query ${this.toString()}`);
            this.emit('entityAdded', entityId);
        };
        this.emitRemoved = (entityId) => {
            this.game.logger.debug(`Entity ${entityId} removed from query ${this.toString()}`);
            this.emit('entityRemoved', entityId);
        };
        this.destroy = () => {
            this.reset();
            this.unsubscribes.forEach((unsub) => unsub());
            this.unsubscribes.length = 0;
            this.emit('destroy');
        };
        this.addedIterable = {
            [Symbol.iterator]: () => new AddedIterator(game, this),
        };
        // when do we reset the frame-specific tracking?
        // right before we populate new values from this frame's operations.
        this.unsubscribes.push(game.subscribe('preApplyOperations', this.resetStepTracking));
        // after we apply operations and register all changes for the frame,
        // we do processing of final add/remove list
        this.unsubscribes.push(game.subscribe('stepComplete', this.processAddRemove));
    }
    initialize(def) {
        this.filter = this.processDef(def);
        Object.values(this.game.archetypeManager.archetypes).forEach(this.matchArchetype);
        this.unsubscribeArchetypes = this.game.archetypeManager.subscribe('archetypeCreated', this.matchArchetype);
        // reset all tracking arrays
        this.trackedEntities.length = 0;
        this.addedThisFrame.length = 0;
        this.removedThisFrame.length = 0;
        this.changesThisFrame = 0;
        // bootstrap entities list -
        // TODO: optimize?
        for (const ent of this) {
            this.trackedEntities.push(ent.id);
            this.addedThisFrame.push(ent.id);
            this.emitAdded(ent.id);
        }
    }
    [Symbol.iterator]() {
        return this.iterator;
    }
    toString() {
        return this.filter
            .map((filterItem) => {
            if (isFilter(filterItem)) {
                return filterItem.toString();
            }
            return filterItem.name;
        })
            .join(',');
    }
    get archetypeIds() {
        return this.archetypes.map((a) => a.id);
    }
    get entities() {
        return this.trackedEntities;
    }
    get addedIds() {
        return this.addedThisFrame;
    }
    get added() {
        return this.addedIterable;
    }
    get removedIds() {
        return this.removedThisFrame;
    }
    get count() {
        return this.trackedEntities.length;
    }
}
class AddedIterator {
    constructor(game, query) {
        this.game = game;
        this.query = query;
        this.index = 0;
        this.result = {
            done: true,
            value: null,
        };
    }
    next() {
        if (this.index >= this.query.addedIds.length) {
            this.result.done = true;
            return this.result;
        }
        this.result.done = false;
        this.result.value = this.game.get(this.query.addedIds[this.index]);
        return this.result;
    }
}
//# sourceMappingURL=Query.js.map