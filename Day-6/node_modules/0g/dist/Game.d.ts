import { QueryManager } from './QueryManager.js';
import { ComponentManager } from './ComponentManager.js';
import { IdManager } from './IdManager.js';
import { ArchetypeManager } from './ArchetypeManager.js';
import { Operation } from './operations.js';
import { Entity } from './Entity.js';
import { Resources } from './Resources.js';
import { ObjectPool } from './internal/objectPool.js';
import { AssetLoaderImpls, Assets } from './Assets.js';
import { QueryComponentFilter } from './Query.js';
import { EntityImpostorFor } from './QueryIterator.js';
import { type AssetLoaders, type BaseShape, type Globals } from './index.js';
import { ComponentHandle } from './Component2.js';
import { Logger } from './logger.js';
export type GameConstants = {
    maxComponentId: number;
    maxEntities: number;
};
export type GameEvents = {
    [phase: `phase:${string}`]: any;
    stepComplete(): any;
    preApplyOperations(): any;
    destroyEntities(): any;
};
export declare class Game {
    private events;
    private _queryManager;
    private _entityIds;
    private _archetypeManager;
    private _stepOperationQueue;
    private _phaseOperationQueue;
    private _componentManager;
    private _globals;
    private _runnableCleanups;
    private _entityPool;
    private _removedList;
    private _assets;
    private _phases;
    private _delta;
    private _time;
    private _constants;
    readonly logger: Logger;
    constructor({ assetLoaders, ignoreSystemsWarning, phases, logLevel, }?: {
        assetLoaders?: AssetLoaderImpls<AssetLoaders>;
        ignoreSystemsWarning?: boolean;
        phases?: string[];
        logLevel?: 'debug' | 'info' | 'warn' | 'error';
    });
    get entityIds(): IdManager;
    get componentManager(): ComponentManager;
    get archetypeManager(): ArchetypeManager;
    get delta(): number;
    get time(): number;
    get queryManager(): QueryManager;
    get constants(): GameConstants;
    get globals(): Resources<Globals>;
    get assets(): Assets<AssetLoaders>;
    get entityPool(): ObjectPool<Entity<ComponentHandle>>;
    subscribe: <K extends keyof GameEvents>(event: K, listener: GameEvents[K]) => () => void;
    /**
     * Allocates a new entity id and enqueues an operation to create the entity at the next opportunity.
     */
    create: () => number;
    /**
     * Enqueues an entity to be destroyed at the next opportunity
     */
    destroy: (id: number) => void;
    /**
     * Add a component to an entity.
     */
    add: <ComponentShape extends BaseShape>(entity: number | Entity, handle: ComponentHandle<ComponentShape>, initial?: Partial<ComponentShape>) => void;
    /**
     * Remove a component by type from an entity
     */
    remove: <T extends ComponentHandle, E extends Entity<any>>(entity: number | E, Type: T) => void;
    /**
     * Get a single entity by its known ID
     */
    get: (entityId: number) => Entity<any> | null;
    /**
     * Run some logic for each entity that meets an ad-hoc query.
     */
    query: <Filter extends QueryComponentFilter>(filter: Filter, run: (entity: EntityImpostorFor<Filter>, game: this) => void) => void;
    find: <Filter extends QueryComponentFilter>(filter: Filter) => EntityImpostorFor<Filter>[];
    findFirst: <Filter extends QueryComponentFilter>(filter: Filter) => EntityImpostorFor<Filter> | null;
    /**
     * Manually step the game simulation forward. Provide a
     * delta (in ms) of time elapsed since last frame.
     */
    step: (delta: number) => void;
    enqueuePhaseOperation: (operation: Operation) => void;
    enqueueStepOperation: (operation: Operation) => void;
    private destroyEntity;
    private flushPhaseOperations;
    private flushStepOperations;
    private applyOperation;
}
