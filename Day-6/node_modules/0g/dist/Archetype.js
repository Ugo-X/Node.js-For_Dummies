import { EventSubscriber } from '@a-type/utils';
import { getIdSignifier } from './ids.js';
/**
 * Archetype is a group of Entities which share a common component signature.
 * Archetypes are the storage system for Entities; each Entity traces back to an Archetype's
 * entities array. When Entity components change, they are moved from Archetype to Archetype.
 * Grouping in this way is a helpful shortcut to fulfilling Query filter requirements,
 * as we only need to map a small number of Archetypes -> Query, versus iterating over
 * and checking every Entity in the system at init and then on every change.
 */
export class Archetype extends EventSubscriber {
    constructor(id) {
        super();
        this.id = id;
        this.entities = new Array();
        /** Maps entity ID -> index in entity array */
        this.entityIndexLookup = new Array();
        this.hasAll = (types) => {
            const masked = types
                .reduce((m, T) => {
                m[T.id] = '1';
                return m;
            }, this.id.split(''))
                .join('');
            return this.id === masked;
        };
        this.hasSome = (types) => {
            for (var T of types) {
                if (this.id[T.id] === '1')
                    return true;
            }
            return false;
        };
        this.includes = (Type) => {
            return this.id[Type.id] === '1';
        };
        this.omits = (Type) => {
            return !this.includes(Type);
        };
    }
    /**
     * Archetype is iterable; iterating it will iterate over its stored
     * Entities.
     *
     * TODO: reverse?
     */
    [Symbol.iterator]() {
        return this.entities[Symbol.iterator]();
    }
    setLookup(entityId, index) {
        this.entityIndexLookup[getIdSignifier(entityId)] = index;
    }
    getLookup(entityId) {
        return this.entityIndexLookup[getIdSignifier(entityId)];
    }
    clearLookup(entityId) {
        this.entityIndexLookup[getIdSignifier(entityId)] = undefined;
    }
    addEntity(entity) {
        // this is the index ("column") of this entity in the table
        const index = this.entities.length;
        // for lookup later when presented with an entityId
        this.setLookup(entity.id, index);
        // add entity data to the column of all data arrays
        this.entities[index] = entity;
        this.emit('entityAdded', entity);
    }
    /**
     * Removes an entity from the archetype table, returning its
     * component data list
     */
    removeEntity(entityId) {
        const index = this.getLookup(entityId);
        if (index === undefined) {
            throw new Error(`Tried to remove ${entityId} from archetype ${this.id}, but was not present`);
        }
        this.clearLookup(entityId);
        const [entity] = this.entities.splice(index, 1);
        // FIXME: improve this!!! Maybe look into a linked list like that one blog post...
        // decrement all entity index lookups that fall after this index
        for (let i = 0; i < this.entityIndexLookup.length; i++) {
            if (this.entityIndexLookup[i] && this.entityIndexLookup[i] > index) {
                this.entityIndexLookup[i]--;
            }
        }
        this.emit('entityRemoved', entityId);
        return entity;
    }
    getEntity(entityId) {
        const index = this.getLookup(entityId);
        if (index === undefined) {
            throw new Error(`Could not find entity ${entityId} in archetype ${this.id}`);
        }
        return this.entities[index];
    }
    toString() {
        return this.id;
    }
}
//# sourceMappingURL=Archetype.js.map