import { componentTypeIds } from './IdManager.js';
export const COMPONENT_CHANGE_HANDLE = Symbol('Component change handle');
const defaultSerialize = (instance) => {
    const gettersAndSetters = {};
    const data = {};
    const descriptors = Object.getOwnPropertyDescriptors(instance);
    Object.keys(descriptors).forEach((key) => {
        const descriptor = descriptors[key];
        if (typeof (descriptor === null || descriptor === void 0 ? void 0 : descriptor.get) === 'function' ||
            typeof (descriptor === null || descriptor === void 0 ? void 0 : descriptor.set) === 'function') {
            gettersAndSetters[key] = descriptor;
        }
        else if (descriptor.enumerable &&
            descriptor.value &&
            !(typeof descriptor.value === 'function')) {
            data[key] = descriptor.value;
        }
    });
    return JSON.stringify(data);
};
const defaultDeserialize = (serialized, additionalProperties) => {
    const data = JSON.parse(serialized);
    Object.defineProperties(data, additionalProperties);
    return data;
};
export const componentTypeMap = new Map();
const componentNameSet = new Set();
function createComponentDefinition(name, init, options) {
    if (componentNameSet.has(name)) {
        throw new Error(`Component name "${name}" already exists. Names must be unique. Use "namespace" to avoid conflicts.`);
    }
    const handle = {
        id: componentTypeIds.get(),
        name,
        defaults: init,
    };
    componentTypeMap.set(handle.id, handle);
    function reset(instance) {
        Object.assign(instance, init());
    }
    function initialize(pooled, initial, id) {
        Object.assign(pooled, init(), initial);
        const $ = ((callback) => {
            callback();
            pooled.$.changed = true;
        });
        Object.defineProperties($, {
            id: { value: id, writable: false },
            type: { value: handle, writable: false },
            changed: {
                get() {
                    console.warn('changed never returns true');
                    return false;
                },
                set(_) {
                    var _a;
                    (_a = $[COMPONENT_CHANGE_HANDLE]) === null || _a === void 0 ? void 0 : _a.call($, pooled);
                },
            },
        });
        pooled.$ = $;
    }
    function create() {
        const instance = init();
        const extensions = options === null || options === void 0 ? void 0 : options.extensions;
        if (extensions) {
            Object.keys(extensions).forEach((key) => {
                Object.defineProperty(instance, key, {
                    get: () => extensions[key](instance),
                });
            });
        }
        initialize(instance, {}, 0);
        return instance;
    }
    function isInstance(instance) {
        if (!('$' in instance))
            return false;
        return instance.$.type.id === handle.id;
    }
    Object.assign(handle, Object.assign({ reset,
        create,
        initialize,
        isInstance }, options));
    return handle;
}
export function component(name, init, options) {
    return createComponentDefinition(name, init, Object.assign({ serialize: defaultSerialize, deserialize: defaultDeserialize }, options));
}
export function state(name, init, options) {
    return createComponentDefinition(name, init, options);
}
export function namespace(ns) {
    function namespacedComponent(name, init, options) {
        return component(`${ns}:${name}`, init, options);
    }
    function namespacedState(name, init, options) {
        return state(`${ns}:${name}`, init, options);
    }
    return {
        component: namespacedComponent,
        state: namespacedState,
    };
}
//# sourceMappingURL=Component2.js.map