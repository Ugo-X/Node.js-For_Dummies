import { EventSubscriber } from '@a-type/utils';
import { ComponentHandle } from './Component2.js';
import { Entity } from './Entity.js';
export type ArchetypeEvents = {
    entityAdded(entity: Entity<any>): any;
    entityRemoved(entityId: number): any;
};
/**
 * Archetype is a group of Entities which share a common component signature.
 * Archetypes are the storage system for Entities; each Entity traces back to an Archetype's
 * entities array. When Entity components change, they are moved from Archetype to Archetype.
 * Grouping in this way is a helpful shortcut to fulfilling Query filter requirements,
 * as we only need to map a small number of Archetypes -> Query, versus iterating over
 * and checking every Entity in the system at init and then on every change.
 */
export declare class Archetype<T extends ComponentHandle[] = ComponentHandle[]> extends EventSubscriber<ArchetypeEvents> {
    id: string;
    private entities;
    /** Maps entity ID -> index in entity array */
    private entityIndexLookup;
    constructor(id: string);
    /**
     * Archetype is iterable; iterating it will iterate over its stored
     * Entities.
     *
     * TODO: reverse?
     */
    [Symbol.iterator](): IterableIterator<Entity<T[number]>>;
    private setLookup;
    private getLookup;
    private clearLookup;
    addEntity(entity: Entity<any>): void;
    /**
     * Removes an entity from the archetype table, returning its
     * component data list
     */
    removeEntity(entityId: number): Entity<T[number]>;
    getEntity(entityId: number): Entity<T[number]>;
    hasAll: (types: ComponentHandle[]) => boolean;
    hasSome: (types: ComponentHandle[]) => boolean;
    includes: (Type: ComponentHandle) => boolean;
    omits: (Type: ComponentHandle) => boolean;
    toString(): string;
}
