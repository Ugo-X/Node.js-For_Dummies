# NODE FUNDAMENTALS AND DEEP DIVE.
# NODE
* What is Node?
* Brief intro
 * The concept of running javascript code in our browser spans off from the browsers having an enabler, usually called a javascript engine. A javascript engine is a software component typically within a browser or other runtime environments like node, that executes JavaScript code.
 Examples of javascript engines and their corresponding browsers are:
 ** V8 used in google chrome
 ** SpiderMonkey used by Mozilla in firefox and 
 ** JavaScriptCore used by Apple for it's safari browser 

# Node is a Javascript runtime environment that employs the use of google's V8 javascript engine. 


# what is a runtime and what are the peculiarities as concerns node in particular 

In relation to Node.js, a runtime environment refers to the software platform that executes your Node.js code. It provides the necessary resources and functionalities for your code to run effectively. Here's a breakdown of the concept:

** Node.js as a JavaScript Runtime:

- Traditionally, JavaScript was primarily executed within web browsers. Browsers have built-in JavaScript engines that interpret and run the code, allowing for interactive web pages.
- Node.js, however, is a different kind of JavaScript runtime environment. It's designed to run JavaScript code outside of a web browser, specifically on the server-side.

** Components of a Node.js Runtime Environment:

- ** JavaScript Engine: At its core, Node.js relies on a JavaScript engine, similar to those found in web browsers. A popular example is the V8 engine developed by Google, which is also used in Chrome. The engine interprets and executes your Node.js code.
- ** Event Loop: Node.js employs an event-driven, non-blocking I/O (Input/Output) model. This means it can handle multiple tasks concurrently without waiting for one operation to complete before starting another. The event loop manages asynchronous operations and callbacks, ensuring efficient handling of requests and responses.
- ** Modules: Node.js leverages a rich ecosystem of modules (also called packages) that provide additional functionalities. These modules can be installed using the Node Package Manager (npm) and used in your code to perform various tasks like file system access, database interaction, network communication, and more.
- ** Built-in APIs: Node.js provides a set of built-in APIs (Application Programming Interfaces) that offer functionalities specific to server-side development. These APIs allow your code to interact with the underlying operating system, network, and file system.

** Key Points about Node.js Runtime:

- ** Flexibility: The Node.js runtime allows you to write server-side applications using JavaScript, a language traditionally used for front-end web development. This enables a more unified approach to development for both front-end and back-end components.
- ** Efficiency: The event loop model and non-blocking I/O make Node.js efficient at handling concurrent requests, particularly for applications dealing with real-time data or large numbers of connections.
- ** Scalability: Node.js applications can scale horizontally by adding more server instances to handle increased traffic, making them suitable for building scalable web services.

** In Summary:

The Node.js runtime environment provides the foundation for running your JavaScript code outside of a web browser. It offers a JavaScript engine, event loop, modular system, and built-in APIs to enable efficient and scalable server-side development.



# Functionalities
1 when you run the command "node" without adding any additions to it, you enter into a mode designated as REPL(Read, evaluate, print and loop)
  ** cons of the REPL are that we cannot save our code and we cannot edit the previously written code.


# like the browser has the window object, node has the process as equivalent which provides information about and control over the current Node.js process.


#libuv is this node highly optimised internal component library of code written in c(deals with input and output paths) that node can delegate to other parts of your system



#libuv internal dive in
*libuv is a multi platform support library with a focus on asynchronous i/o 
node.js allows us to make use of libuv by connecting to it with the node.js bindings, which allows the functionality in libuv to be used by our javascript

============================================
26 non-blocking and blocking functionalities
============================================
## 
* Blocking functions are synchronous functions, whereas non blocking functions are asynchronous functions

=====================
#30 THE EVENT LOOP
=====================
The event loop is a component of node that is responsible for the callbacks that enable node to run/execute code asynchronously(do multiple things at once even though JavaScriptis single threaded)
Absolutely! Here's a breakdown of callback queues in Node.js/JavaScript:

Concept:

- In Node.js, which is single-threaded, callback queues are a mechanism used to manage asynchronous operations.
- When your code encounters an asynchronous operation (like reading a file, making a network request, or using `setTimeout`), it doesn't wait for that operation to complete before continuing.
- Instead, the code registers a callback function with the event loop. This callback function contains the code that should be executed once the asynchronous operation finishes.
- The callback function is then placed in a queue called the "callback queue."

Event Loop:

- The event loop is a core component in Node.js that continuously checks two main things:
    - Stack: The event loop first checks the call stack. This is where synchronous code is executed line by line. As long as there's code in the call stack, the event loop keeps executing it.
    - **Callback Queue:** Once the call stack is empty (meaning no more synchronous code to execute), the event loop moves on to the callback queue. It retrieves the first function from the queue and adds it to the call stack, where it's finally executed.

Benefits:

- Callback queues enable Node.js to handle multiple asynchronous operations concurrently without blocking the main thread. This is because the event loop can keep processing other code while waiting for asynchronous operations to finish.
- They improve responsiveness because the event loop can continue executing other parts of your program while waiting for asynchronous tasks.

Drawbacks:

- Callback hell: Nesting callbacks deeply can make code hard to read and maintain. Promises and async/await offer more structured alternatives for handling asynchronous operations.

**Alternatives:**

- Promises: Promises provide a more structured way to handle asynchronous operations. They offer methods like `then` and `catch` to chain operations and handle potential errors.
- Async/await: Async/await syntax builds on top of promises, allowing you to write asynchronous code that resembles synchronous code. This can improve readability and maintainability.

Summary:

- Callback queues are a fundamental concept in Node.js for handling asynchronous operations efficiently.
- While they offer benefits like non-blocking I/O, consider using promises or async/await for improved code readability and maintainability as your projects grow.






=========================
EVENT LOOP AND IT'S PHASES
=========================